"""Prototype of differential privacy system for eventual implementation on a Lattice ice40 FPGA
Gregory Brooks 2018


Based on the following references:

Choi, Woo-Seok & Tomei, Matthew & Rodrigo Sanchez Vicarte, Jose & Kumar Hanumolu, Pavan & Kumar, Rakesh. (2018).
Guaranteeing Local Differential Privacy on Ultra-Low-Power Systems. 561-574. 10.1109/ISCA.2018.00053.

Christian de Schryver, Daniel Schmidt, Norbert Wehn, et al., “A Hardware Efficient Random Number Generator for
Nonuniform Distributions with Arbitrary Precision,” International Journal of Reconfigurable Computing, vol. 2012,
Article ID 675130, 11 pages, 2012.
"""

from random import getrandbits, random
from dataclasses import dataclass

@dataclass
class RandFloat:
    """m bit floating point representation used by de Schryver et al.

    symm     -- symmetry bit indicates which half of a symmetrical ICDF the random value lies within
    part     -- part bit splits the encoded half of the ICDF into two parts
    exponent -- m - mant_bw - 2 bits
    mantissa -- mant_bw bits
    m        -- number of bits in floating point representation
    mant_bw  -- number of bits in mantissa
    """
    symm: bool
    part: bool
    exponent: int
    mantissa: int
    # m: int
    # mant_bw: int

    # def bits(self):
    #     bits = self.exponent + self.mantissa
    #     bits
    #     return

class FloatingPointConverter:
    """Algorithm to convert from URNG output to floating point representation described by de Schryver et al.

    Bx      -- number of random bits generated by the URNG
    k       -- each 'octave' is divided into 2**k 'subsections'
    mant_bw -- width of mantissa of floating point URNG output representation
    """

    def __init__(self, Bx, k, mant_bw):
        self.Bx = Bx
        self.k = k
        self.mant_bw = mant_bw

        self.exp_bw = self.Bx - 2 - self.mant_bw  # Width of exponent in floating point URNG output representation
        self.data_valid = False

    def urngToFloatingPoint(self, rn, Bx = None, k = None, mant_bw = None):
        """Convert URNG output to floating point form

        rn      -- URNG output
        Bx      -- Number of bits in URNG output.
        k       -- each 'octave' is divided into 2**k 'subsections'
        mant_bw -- width of mantissa of floating point URNG output representation
        """
        rn &= 2 ** Bx - 1  # sanity check

        if Bx is None:
            Bx = self.Bx
        if k is None:
            k = self.k
        if mant_bw is None:
            mant_bw = self.mant_bw

        symm = rn & 2 ** (Bx - 1)  # MSB
        part = rn & 2 ** (Bx - 2)

        #TODO: finish
        # exponent: int
        # mantissa: int

        return RandFloat(symm, part, exponent, mantissa)


class Urng:
    """Simulate fixed point RNG."""
    def __init__(self, Bx, By):
        """Initialise object, set the number of bits used by URNG and Laplace output.
        Conversion from URNG to Laplace distribution is described by de Schryver et al.

        # Notation from Choi et al.
        Bx -- number of random bits generated by the URNG
        By -- number of random bits in the RNG output (Laplace distribution)
        """

        self.Bx = Bx
        self.By = By

    def urng(self, bits=None):
        """Return a random number from the URNG.

        bits -- (Optional) number of bits in random output. Defaults to value set during Rng.init()
        """
        if bits is None:
            bits = self.Bx
        random_bits = getrandbits(bits)
        return random_bits


class Sensor:
    """Represents hardware sensor and driver, output is a base Newton signal."""
    def __init__(self, minimum, maximum):
        """Initialise object, set the range of the sensor output.

        min -- minimum sensor output
        max -- maximum sensor output
        """
        self.min = min(minimum, maximum)  # Ensure max and min are the right way round
        self.max = max(minimum, maximum)
        self.d = self.max - self.min  # Notation from Choi et al.

    def read(self):
        """Simulate reading from the physical sensor."""
        return self.min + self.d * random()  # Return a random value within the sensor range


if __name__ == '__main__':
    pass
