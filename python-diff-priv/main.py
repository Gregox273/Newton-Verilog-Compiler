"""Prototype of differential privacy system for eventual implementation on a Lattice ice40 FPGA
Gregory Brooks 2018


Based on the following references:

Choi, Woo-Seok & Tomei, Matthew & Rodrigo Sanchez Vicarte, Jose & Kumar Hanumolu, Pavan & Kumar, Rakesh. (2018).
Guaranteeing Local Differential Privacy on Ultra-Low-Power Systems. 561-574. 10.1109/ISCA.2018.00053.

Christian de Schryver, Daniel Schmidt, Norbert Wehn, et al., “A Hardware Efficient Random Number Generator for
Nonuniform Distributions with Arbitrary Precision,” International Journal of Reconfigurable Computing, vol. 2012,
Article ID 675130, 11 pages, 2012.
"""

from random import getrandbits, random
from dataclasses import dataclass
import itertools
from bitarray import bitarray

DEBUG = True


@dataclass
class RandFloat:
    """m bit floating point representation used by de Schryver et al.

    symm     -- symmetry bit indicates which half of a symmetrical ICDF the random value lies within
    part     -- part bit splits the encoded half of the ICDF into two parts
    exponent -- m - mant_bw - 2 bits
    mantissa -- mant_bw bits
    m        -- number of bits in floating point representation
    mant_bw  -- number of bits in mantissa
    """
    symm: bool
    part: bool
    exponent: int
    mantissa: int
    m: int
    mant_bw: int

    def to_int(self):
        bits = (self.exponent << self.mant_bw) + self.mantissa
        bits |= (self.part << self.m - 2)
        bits |= (self.symm << self.m - 1)
        return bits


class Rng:
    """Simulate fixed point RNG."""
    def __init__(self, Bx, By, k, mant_bw, max_exp):
        """Initialise object, set the number of bits used by URNG and Laplace output.
        Conversion from URNG to Laplace distribution is described by de Schryver et al.

        # Notation from Choi et al.
        Bx      -- number of random bits generated by the URNG
        By      -- number of random bits in the RNG output (Laplace distribution)

        # Inversion method by de Schryver et al.
        k       -- each 'octave' is divided into 2**k 'subsections'
        mant_bw -- width of mantissa of floating point URNG output representation
        max_exp -- maximum exponent value
        """

        self.Bx = Bx
        self.By = By

        self.Bx = Bx
        self.k = k
        self.mant_bw = mant_bw
        self.max_exp = max_exp

        self.exp_bw = self.Bx - 2 - self.mant_bw  # Width of exponent in floating point URNG output representation

    def urng(self, bits=None):
        """Return a random number from the URNG.

        bits -- (Optional) number of bits in random output. Defaults to value set during Rng.init()
        """
        if bits is None:
            bits = self.Bx
        random_bits = getrandbits(bits)

        if DEBUG:
            print("URNG output: {}".format(bin(random_bits)))
        return random_bits

    def floating_point(self):
        """Convert URNG output to floating point form
        """
        rn = self.urng()

        # Boolean values (single bit)
        symm = rn & 2 ** (self.Bx - 1)  # MSB
        part = rn & 2 ** (self.Bx - 2)

        # Divide up the remaining bits
        exponent_part = self.get_exponent(rn)
        mantissa = self.get_mantissa(rn)

        # Exponent is calculated by counting leading zeros
        leading_zeros = self.count_leading_zeros(exponent_part, self.exp_bw)
        while exponent_part == 0 and leading_zeros < self.max_exp:
            exponent_part = self.get_exponent(self.urng())
            leading_zeros += self.count_leading_zeros(exponent_part, self.exp_bw)
        exponent = min(leading_zeros, self.max_exp)

        return RandFloat(symm!=0, part!=0, exponent, mantissa, self.Bx, self.mant_bw)

    def get_exponent(self, rn):
        return (rn & (2 ** (self.Bx - 2) - 1)) >> self.mant_bw

    def get_mantissa(self, rn):
        return rn & 2 ** self.mant_bw - 1

    @staticmethod
    def count_leading_zeros(val, num_bits):
        if val == 0:
            return 1
        cursor = 2 ** (num_bits - 1)
        count = 0
        while val & cursor == 0:
            count += 1
            cursor >> 1
            if cursor == 0:
                break


class Invariant:
    """Represents a relationship between variables, described in a Newton invariant."""

    # ID bit for a sensor is set to 1 when sensor is read, and not reset until privacy budget is fully replenished.
    read_bitfield = bitarray()

    def __init__(self, fn, sensors):
        """Define relationship between sensor measurements.

        fn      -- mathematical equation relating sensor measurements
        sensors -- measurements being related i.e. arguments to fn.
                    List of unique sensor IDs in the order accepted by self.fn()
        """
        self.fn = fn
        self.sensors = sensors
        # Create bitfield to list all the sensors involved in the invariant
        self.bitfield = bitarray(len(sensors))
        for ID in sensors:
            self.bitfield[ID] = 1


class HardwareSensor:
    """Represents hardware sensor and driver, output is a base Newton signal."""
    def __init__(self, minimum, maximum):
        """Initialise object, set the range of the sensor output.

        minimum -- minimum sensor output
        maximum -- maximum sensor output
        """
        self.min = min(minimum, maximum)  # Ensure max and min are the right way round
        self.max = max(minimum, maximum)
        self.d = self.max - self.min  # Notation from Choi et al.

    def read(self):
        """Simulate reading from the physical sensor."""
        return self.min + self.d * random()  # Return a random value within the sensor range


class Sensor(HardwareSensor):
    """Represents sensor along with additional privacy information supplied along with Newton description.

    minimum    -- minimum sensor output
    maximum    -- maximum sensor output
    budget_max -- privacy budget (units ε)
    rep_rate   -- budget replenishment rate (per arbitrary time uint)
    epsilon    -- privacy factor (smaller value means greater privacy)
    invariants -- list of all nvariants involving the sensor
    """

    next_id = itertools.count().next

    def __init__(self, minimum, maximum, budget_max, rep_rate, epsilon, invariants):
        super().__init__(minimum, maximum)
        self.budget_max = budget_max
        self.budget = budget_max
        self.rep_rate = rep_rate
        self.epsilon = epsilon
        self.invariants = invariants

        self.id = Sensor.next_id()  # Unique ID
        Invariant.read_bitfield.append(0)
        self.prev_return_value = 0  # Last query response returned

    def query(self):
        noise = random()  # Todo: replace with Laplace(self.d/self.epsilon) noise, using Schryver et al. and Choi et al. techniques

        privacy_loss = 1  # Todo: calculate privacy loss (a function of random value)

        # Todo: calculate privacy loss for all related sensors and perform this check for all of them

        if self.budget > privacy_loss:
            self.budget -= privacy_loss
            Invariant.read_bitfield[ID] = 1
            true_measurement = super().read()
            self.prev_return_value = true_measurement + noise
            return self.prev_return_value
        else:
            # If insufficient privacy budget, return the last value i.e. no information revealed
            return self.prev_return_value

    def rep_clock(self, number=1):
        """Apply 'number' privacy budget replenishment clock pulses.

        number -- number of pulses to apply, each replenishes the budget by rep_rate
        """
        budget_increase = number * self.rep_rate
        if self.budget < self.budget_max - budget_increase:
            self.budget += budget_increase
        else:
            self.budget = self.budget_max
            Invariant.read_bitfield[ID] = 0


if __name__ == '__main__':
    sensor_list = [HardwareSensor(i, 100 + 2*i) for i in range(3)]  # Arbitrary sensors with arbitrary limits
    rng = Rng(8, 16, 2, 3, 3)
    print("Floating point URNG output: {}".format(bin(rng.floating_point().to_int())))
