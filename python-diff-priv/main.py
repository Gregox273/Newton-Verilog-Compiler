"""Prototype of differential privacy system for eventual implementation on a Lattice ice40 FPGA
Gregory Brooks 2018


Based on the following references:

Choi, Woo-Seok & Tomei, Matthew & Rodrigo Sanchez Vicarte, Jose & Kumar Hanumolu, Pavan & Kumar, Rakesh. (2018).
Guaranteeing Local Differential Privacy on Ultra-Low-Power Systems. 561-574. 10.1109/ISCA.2018.00053.

Christian de Schryver, Daniel Schmidt, Norbert Wehn, et al., “A Hardware Efficient Random Number Generator for
Nonuniform Distributions with Arbitrary Precision,” International Journal of Reconfigurable Computing, vol. 2012,
Article ID 675130, 11 pages, 2012.
"""

from random import getrandbits, random
from dataclasses import dataclass

DEBUG = True


@dataclass
class RandFloat:
    """m bit floating point representation used by de Schryver et al.

    symm     -- symmetry bit indicates which half of a symmetrical ICDF the random value lies within
    part     -- part bit splits the encoded half of the ICDF into two parts
    exponent -- m - mant_bw - 2 bits
    mantissa -- mant_bw bits
    m        -- number of bits in floating point representation
    mant_bw  -- number of bits in mantissa
    """
    symm: bool
    part: bool
    exponent: int
    mantissa: int
    m: int
    mant_bw: int

    def to_int(self):
        bits = (self.exponent << self.mant_bw) + self.mantissa
        bits |= (self.part << self.m - 2)
        bits |= (self.symm << self.m - 1)
        return bits


class Rng:
    """Simulate fixed point RNG."""
    def __init__(self, Bx, By, k, mant_bw, max_exp):
        """Initialise object, set the number of bits used by URNG and Laplace output.
        Conversion from URNG to Laplace distribution is described by de Schryver et al.

        # Notation from Choi et al.
        Bx      -- number of random bits generated by the URNG
        By      -- number of random bits in the RNG output (Laplace distribution)

        # Inversion method by de Schryver et al.
        k       -- each 'octave' is divided into 2**k 'subsections'
        mant_bw -- width of mantissa of floating point URNG output representation
        max_exp -- maximum exponent value
        """

        self.Bx = Bx
        self.By = By

        self.Bx = Bx
        self.k = k
        self.mant_bw = mant_bw
        self.max_exp = max_exp

        self.exp_bw = self.Bx - 2 - self.mant_bw  # Width of exponent in floating point URNG output representation

    def urng(self, bits=None):
        """Return a random number from the URNG.

        bits -- (Optional) number of bits in random output. Defaults to value set during Rng.init()
        """
        if bits is None:
            bits = self.Bx
        random_bits = getrandbits(bits)

        if DEBUG:
            print("URNG output: {}".format(bin(random_bits)))
        return random_bits

    def floating_point(self):
        """Convert URNG output to floating point form
        """
        rn = self.urng()

        # Boolean values (single bit)
        symm = rn & 2 ** (self.Bx - 1)  # MSB
        part = rn & 2 ** (self.Bx - 2)

        # Divide up the remaining bits
        exponent_part = self.get_exponent(rn)
        mantissa = self.get_mantissa(rn)

        # Exponent is calculated by counting leading zeros
        leading_zeros = self.count_leading_zeros(exponent_part, self.exp_bw)
        while exponent_part == 0 and leading_zeros < self.max_exp:
            exponent_part = self.get_exponent(self.urng())
            leading_zeros += self.count_leading_zeros(exponent_part, self.exp_bw)
        exponent = min(leading_zeros, self.max_exp)

        return RandFloat(symm!=0, part!=0, exponent, mantissa, self.Bx, self.mant_bw)

    def get_exponent(self, rn):
        return (rn & (2 ** (self.Bx - 2) - 1)) >> self.mant_bw

    def get_mantissa(self, rn):
        return rn & 2 ** self.mant_bw - 1

    @staticmethod
    def count_leading_zeros(val, num_bits):
        if val == 0:
            return 1
        cursor = 2 ** (num_bits - 1)
        count = 0
        while val & cursor == 0:
            count += 1
            cursor >> 1
            if cursor == 0:
                break

        return count


class Sensor:
    """Represents hardware sensor and driver, output is a base Newton signal."""
    def __init__(self, minimum, maximum):
        """Initialise object, set the range of the sensor output.

        min -- minimum sensor output
        max -- maximum sensor output
        """
        self.min = min(minimum, maximum)  # Ensure max and min are the right way round
        self.max = max(minimum, maximum)
        self.d = self.max - self.min  # Notation from Choi et al.

    def read(self):
        """Simulate reading from the physical sensor."""
        return self.min + self.d * random()  # Return a random value within the sensor range


if __name__ == '__main__':
    sensors = [Sensor(i, 100 + 2*i) for i in range(3)]  # Arbitrary sensors with arbitrary limits
    rng = Rng(8, 16, 2, 3, 3)
    print("Floating point URNG output: {}".format(bin(rng.floating_point().to_int())))
